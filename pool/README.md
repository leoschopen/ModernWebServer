# 数据库连接池
这是一个数据库连接池的实现，用于提供数据库连接的复用，避免频繁地创建和销毁数据库连接。该实现使用了单例模式，使用时调用 `SqlConnPool::Instance()` 即可获取该连接池的唯一实例。

该连接池的实现使用了一个队列来存储多个数据库连接对象，该队列的大小由构造函数中的参数 `connSize` 确定，每次从队列中获取一个数据库连接对象时，该对象会被移除队列，使用结束后再次被放回队列中，以实现复用。

为了避免多线程下的竞争，该连接池实现使用了互斥锁 `std::mutex` 和信号量 `sem_t` 来保证线程安全。同时为了提高性能，该连接池实现使用了 C++11 中的 `std::lock_guard` 和 `std::unique_lock` 等 RAII 类来避免手动管理锁的释放。

## TODO
- [ ] redis
- [ ] memcache

## 参考开源项目

https://github.com/limingfan2016/game_service_system/tree/master/common/db_lib


# 线程池
在创建每个线程时，代码使用 std::thread() 函数创建一个新线程，
并使用 lambda 函数定义了该线程的主要执行逻辑。在 lambda 函数中，
线程持续运行，直到任务队列为空并且线程池被关闭。在循环中，
线程会等待任务队列中有新任务到来，如果有，就从队列中取出一个任务并执行。
否则，线程将进入等待状态，等待条件变量 cond 的信号通知。

在任务执行过程中，线程会对任务队列的互斥锁 mtx 进行上锁，
以避免多个线程同时访问任务队列。在执行任务之前，线程会将互斥锁释放，
这样其他线程就可以接着执行其他任务。任务执行完成后，
线程又会重新获取互斥锁，并继续等待新的任务到来。在任务队列为空且线程池被关闭的情况下，
线程将退出循环并结束运行。

## 为什么在执行任务之前，线程会将互斥锁释放，为什么不等这个任务执行完毕？
在执行任务之前，线程会将互斥锁释放，是为了避免线程间的互斥等待。如果线程在执行任务之前一直持有互斥锁，那么其他线程就不能访问任务队列，从而无法执行新的任务，这样会导致线程之间的互斥等待，降低程序的并发性能。

因此，为了避免线程之间的互斥等待，当前线程在执行任务之前会先释放互斥锁，让其他线程可以访问任务队列并执行新的任务。等到当前线程再次获取到任务队列的互斥锁时，就可以继续执行下一个任务。

另外，释放互斥锁还可以避免死锁的发生。如果线程在执行任务之前一直持有互斥锁，并且在执行任务时发生了阻塞，那么就会导致其他线程无法访问任务队列，从而造成死锁。因此，为了避免死锁的发生，当前线程需要在执行任务之前释放互斥锁，让其他线程可以访问任务队列。